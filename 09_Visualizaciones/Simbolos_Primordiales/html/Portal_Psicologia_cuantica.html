<!DOCTYPE html>

<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Psicología Cuántica - Trinity Libro 1</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    body {
        background: radial-gradient(ellipse at center, #0a0014 0%, #000000 100%);
        overflow: hidden;
        cursor: crosshair;
        font-family: 'Courier New', monospace;
    }

    canvas {
        display: block;
        width: 100vw;
        height: 100vh;
    }

    .quantum-mind-hud {
        position: absolute;
        top: 20px;
        left: 20px;
        color: rgba(147, 112, 255, 0.9);
        font-size: 11px;
        letter-spacing: 2px;
        z-index: 10;
        background: rgba(0,0,0,0.5);
        padding: 15px;
        border: 1px solid rgba(147, 112, 255, 0.3);
        border-radius: 5px;
    }

    .quantum-mind-hud div {
        margin-bottom: 8px;
        opacity: 0;
        animation: fadeIn 2s forwards;
    }

    .quantum-mind-hud span {
        color: #00ffff;
        font-weight: bold;
        text-shadow: 0 0 5px currentColor;
    }

    @keyframes fadeIn {
        to { opacity: 1; }
    }

    .book-title {
        position: absolute;
        top: 20px;
        right: 20px;
        color: rgba(147, 112, 255, 0.7);
        font-size: 18px;
        font-weight: bold;
        letter-spacing: 3px;
        text-align: right;
        text-shadow: 0 0 10px rgba(147, 112, 255, 0.5);
    }

    .book-subtitle {
        font-size: 11px;
        color: rgba(100, 200, 255, 0.6);
        margin-top: 5px;
    }

    .consciousness-state {
        position: absolute;
        bottom: 20px;
        width: 100%;
        text-align: center;
        color: rgba(255,255,255,0.4);
        font-size: 12px;
        letter-spacing: 3px;
        text-transform: uppercase;
    }

    .neural-info {
        position: absolute;
        bottom: 60px;
        left: 20px;
        color: rgba(147, 112, 255, 0.5);
        font-size: 10px;
        letter-spacing: 1px;
    }
</style>
```

</head>
<body>
    <div class="quantum-mind-hud">
        <div style="animation-delay: 0.5s">ESTADO: <span id="state">SUPERPOSICIÓN</span></div>
        <div style="animation-delay: 1s">COHERENCIA: <span id="coherence">0</span>%</div>
        <div style="animation-delay: 1.5s">ENTRELAZAMIENTO: <span id="entanglement">0</span>%</div>
        <div style="animation-delay: 2s">FRECUENCIA: <span id="frequency">0</span> Hz</div>
        <div style="animation-delay: 2.5s">OBSERVADOR: <span id="observer">ACTIVO</span></div>
        <div style="animation-delay: 3s">COLAPSO: <span id="collapse">PENDIENTE</span></div>
    </div>

```
<div class="book-title">
    PSICOLOGÍA CUÁNTICA
    <div class="book-subtitle">Trinity Origen - Libro 1</div>
</div>

<canvas id="canvas"></canvas>

<div class="consciousness-state" id="consciousness">
    ONDA ↔ PARTÍCULA
</div>

<div class="neural-info">
    <div>SINAPSIS CUÁNTICAS: <span id="synapses">0</span></div>
    <div>NEURONAS ACTIVAS: <span id="neurons">0</span></div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Variables del sistema cuántico-mental
    let time = 0;
    let mouseX = canvas.width / 2;
    let mouseY = canvas.height / 2;
    let observerIntensity = 0;
    let waveFunction = [];
    let collapsed = false;
    let collapsePoint = null;
    let consciousnessState = 'SUPERPOSICIÓN';
    let entanglementLevel = 0;
    let coherencePhase = 0;
    
    // Estados mentales cuánticos
    const mentalStates = [
        'SUPERPOSICIÓN',
        'OBSERVACIÓN',
        'COLAPSO',
        'ENTRELAZAMIENTO',
        'COHERENCIA',
        'DECOHERENCIA',
        'TÚNEL CUÁNTICO',
        'NO-LOCALIDAD'
    ];
    
    // Clase para neuronas cuánticas
    class QuantumNeuron {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.baseX = x;
            this.baseY = y;
            this.connections = [];
            this.activation = 0;
            this.phase = Math.random() * Math.PI * 2;
            this.quantumState = Math.random();
            this.entangled = null;
            this.color = `hsl(${260 + Math.random() * 60}, 70%, 50%)`;
        }
        
        connect(neuron) {
            this.connections.push(neuron);
            if (Math.random() < 0.3) {
                this.entangled = neuron;
                neuron.entangled = this;
            }
        }
        
        update() {
            // Oscilación cuántica
            this.phase += 0.02;
            this.quantumState = (Math.sin(this.phase) + 1) / 2;
            
            // Influencia del observador
            const dx = mouseX - this.x;
            const dy = mouseY - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 200) {
                this.activation = 1 - distance / 200;
                // Colapso de función de onda cerca del observador
                if (distance < 50 && !collapsed) {
                    collapsed = true;
                    collapsePoint = { x: this.x, y: this.y };
                    setTimeout(() => {
                        collapsed = false;
                        collapsePoint = null;
                    }, 1000);
                }
            } else {
                this.activation *= 0.95;
            }
            
            // Entrelazamiento cuántico
            if (this.entangled && this.entangled.activation > 0.5) {
                this.activation = Math.max(this.activation, this.entangled.activation * 0.7);
            }
            
            // Movimiento ondulatorio
            this.x = this.baseX + Math.sin(this.phase) * 10 * this.quantumState;
            this.y = this.baseY + Math.cos(this.phase * 0.7) * 10 * this.quantumState;
        }
        
        draw() {
            // Neurona como partícula/onda
            const radius = 3 + this.activation * 7;
            
            // Halo cuántico
            if (this.activation > 0.1) {
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, radius * 4
                );
                gradient.addColorStop(0, this.color + '40');
                gradient.addColorStop(0.5, this.color + '20');
                gradient.addColorStop(1, 'transparent');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius * 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Núcleo de la neurona
            ctx.fillStyle = this.color;
            ctx.globalAlpha = 0.5 + this.activation * 0.5;
            ctx.beginPath();
            ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Punto cuántico central
            ctx.fillStyle = '#ffffff';
            ctx.globalAlpha = this.activation;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 1, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.globalAlpha = 1;
        }
        
        drawConnections() {
            this.connections.forEach(target => {
                const alpha = (this.activation + target.activation) / 4;
                if (alpha > 0.1) {
                    ctx.strokeStyle = `rgba(147, 112, 255, ${alpha})`;
                    ctx.lineWidth = alpha * 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    
                    // Conexión cuántica ondulatoria
                    const midX = (this.x + target.x) / 2;
                    const midY = (this.y + target.y) / 2;
                    const wave = Math.sin(time * 0.05 + this.phase) * 20;
                    
                    ctx.quadraticCurveTo(
                        midX + wave,
                        midY - wave,
                        target.x, target.y
                    );
                    ctx.stroke();
                    
                    // Partículas de información
                    if (this.activation > 0.5) {
                        const t = (time * 0.02) % 1;
                        const px = this.x + (target.x - this.x) * t;
                        const py = this.y + (target.y - this.y) * t;
                        
                        ctx.fillStyle = '#00ffff';
                        ctx.globalAlpha = alpha;
                        ctx.beginPath();
                        ctx.arc(px, py, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }
                }
            });
        }
    }
    
    // Crear red neuronal cuántica
    const neurons = [];
    const neuronCount = 25;
    
    // Crear neuronas en patrón de cerebro
    for (let i = 0; i < neuronCount; i++) {
        const angle = (Math.PI * 2 / neuronCount) * i;
        const radiusVariation = 150 + Math.random() * 100;
        const x = canvas.width / 2 + Math.cos(angle) * radiusVariation;
        const y = canvas.height / 2 + Math.sin(angle) * radiusVariation;
        neurons.push(new QuantumNeuron(x, y));
    }
    
    // Conectar neuronas
    neurons.forEach((neuron, i) => {
        for (let j = 0; j < 3; j++) {
            const targetIndex = Math.floor(Math.random() * neurons.length);
            if (targetIndex !== i) {
                neuron.connect(neurons[targetIndex]);
            }
        }
    });
    
    // Función de onda
    function initWaveFunction() {
        waveFunction = [];
        for (let i = 0; i < 100; i++) {
            waveFunction.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                amplitude: Math.random(),
                frequency: Math.random() * 0.1,
                phase: Math.random() * Math.PI * 2
            });
        }
    }
    initWaveFunction();
    
    // Dibujar función de onda mental
    function drawWaveFunction() {
        ctx.strokeStyle = 'rgba(100, 200, 255, 0.1)';
        ctx.lineWidth = 1;
        
        waveFunction.forEach(wave => {
            wave.phase += wave.frequency;
            const radius = 50 + Math.sin(wave.phase) * 30 * wave.amplitude;
            
            ctx.beginPath();
            ctx.arc(wave.x, wave.y, radius, 0, Math.PI * 2);
            ctx.stroke();
        });
    }
    
    // Ojo del observador
    function drawObserverEye() {
        const eyeX = canvas.width / 2;
        const eyeY = canvas.height / 2;
        
        // Iris cuántico
        ctx.save();
        ctx.translate(eyeX, eyeY);
        ctx.rotate(time * 0.001);
        
        // Anillos del iris
        for (let i = 5; i > 0; i--) {
            ctx.strokeStyle = `rgba(147, 112, 255, ${0.1 * i})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, 20 * i, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Pupila que sigue al mouse
        const angle = Math.atan2(mouseY - eyeY, mouseX - eyeX);
        const distance = Math.min(10, Math.sqrt(Math.pow(mouseX - eyeX, 2) + Math.pow(mouseY - eyeY, 2)) / 20);
        
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(Math.cos(angle) * distance, Math.sin(angle) * distance, 8, 0, Math.PI * 2);
        ctx.fill();
        
        // Punto de consciencia
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(Math.cos(angle) * distance, Math.sin(angle) * distance, 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
    
    // Colapso de función de onda
    function drawCollapse() {
        if (collapsed && collapsePoint) {
            ctx.save();
            
            for (let i = 0; i < 10; i++) {
                const radius = i * 20 + (time % 20);
                const alpha = Math.max(0, 1 - radius / 200);
                
                ctx.strokeStyle = `rgba(0, 255, 255, ${alpha * 0.5})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(collapsePoint.x, collapsePoint.y, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.restore();
        }
    }
    
    // Patrón de interferencia mental
    function drawInterferencePattern() {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        ctx.strokeStyle = 'rgba(147, 112, 255, 0.05)';
        ctx.lineWidth = 0.5;
        
        for (let i = 0; i < 20; i++) {
            const offset = Math.sin(time * 0.01 + i * 0.5) * 50;
            ctx.beginPath();
            ctx.moveTo(0, centerY + i * 20 - 200 + offset);
            ctx.lineTo(canvas.width, centerY + i * 20 - 200 + offset);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX + i * 20 - 200 + offset, 0);
            ctx.lineTo(centerX + i * 20 - 200 + offset, canvas.height);
            ctx.stroke();
        }
    }
    
    // Partículas de pensamiento
    class ThoughtParticle {
        constructor() {
            this.reset();
        }
        
        reset() {
            this.x = canvas.width / 2;
            this.y = canvas.height / 2;
            const angle = Math.random() * Math.PI * 2;
            this.vx = Math.cos(angle) * (1 + Math.random() * 2);
            this.vy = Math.sin(angle) * (1 + Math.random() * 2);
            this.life = 1;
            this.isWave = Math.random() < 0.5;
        }
        
        update() {
            if (this.isWave) {
                // Comportamiento ondulatorio
                this.x += this.vx;
                this.y += this.vy + Math.sin(time * 0.1 + this.x * 0.01) * 2;
            } else {
                // Comportamiento de partícula
                this.x += this.vx;
                this.y += this.vy;
            }
            
            this.life -= 0.01;
            
            if (this.life <= 0 || this.x < 0 || this.x > canvas.width || 
                this.y < 0 || this.y > canvas.height) {
                this.reset();
            }
        }
        
        draw() {
            if (this.isWave) {
                // Dibujar como onda
                ctx.strokeStyle = `rgba(100, 200, 255, ${this.life * 0.5})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(this.x - 10, this.y);
                for (let i = -10; i <= 10; i++) {
                    ctx.lineTo(this.x + i, this.y + Math.sin(i * 0.5 + time * 0.1) * 3);
                }
                ctx.stroke();
            } else {
                // Dibujar como partícula
                ctx.fillStyle = `rgba(147, 112, 255, ${this.life})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
    
    const thoughtParticles = Array(50).fill().map(() => new ThoughtParticle());
    
    // Animación principal
    function animate() {
        // Fondo con estela
        ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Actualizar fase de coherencia
        coherencePhase += 0.01;
        
        // Dibujar elementos
        drawInterferencePattern();
        drawWaveFunction();
        
        // Actualizar y dibujar neuronas
        neurons.forEach(neuron => {
            neuron.update();
        });
        
        // Dibujar conexiones primero
        neurons.forEach(neuron => {
            neuron.drawConnections();
        });
        
        // Dibujar neuronas encima
        neurons.forEach(neuron => {
            neuron.draw();
        });
        
        // Dibujar ojo observador
        drawObserverEye();
        
        // Dibujar colapso si está activo
        drawCollapse();
        
        // Actualizar y dibujar partículas de pensamiento
        thoughtParticles.forEach(particle => {
            particle.update();
            particle.draw();
        });
        
        // Calcular métricas cuánticas
        const activeNeurons = neurons.filter(n => n.activation > 0.3).length;
        const totalConnections = neurons.reduce((sum, n) => sum + n.connections.length, 0);
        entanglementLevel = neurons.filter(n => n.entangled).length / neurons.length * 100;
        const coherence = Math.abs(Math.sin(coherencePhase)) * 100;
        const frequency = 8 + Math.sin(coherencePhase) * 4; // Ondas Alpha
        
        // Determinar estado de consciencia
        if (collapsed) {
            consciousnessState = 'COLAPSO';
        } else if (activeNeurons > 15) {
            consciousnessState = 'COHERENCIA';
        } else if (entanglementLevel > 50) {
            consciousnessState = 'ENTRELAZAMIENTO';
        } else if (observerIntensity > 0.7) {
            consciousnessState = 'OBSERVACIÓN';
        } else {
            consciousnessState = 'SUPERPOSICIÓN';
        }
        
        // Actualizar HUD
        document.getElementById('state').textContent = consciousnessState;
        document.getElementById('coherence').textContent = Math.floor(coherence);
        document.getElementById('entanglement').textContent = Math.floor(entanglementLevel);
        document.getElementById('frequency').textContent = frequency.toFixed(1);
        document.getElementById('collapse').textContent = collapsed ? 'ACTIVO' : 'PENDIENTE';
        document.getElementById('synapses').textContent = totalConnections;
        document.getElementById('neurons').textContent = activeNeurons;
        
        // Actualizar texto de consciencia
        const wavePercent = thoughtParticles.filter(p => p.isWave).length / thoughtParticles.length * 100;
        document.getElementById('consciousness').textContent = 
            wavePercent > 60 ? 'ONDA DOMINANTE' :
            wavePercent < 40 ? 'PARTÍCULA DOMINANTE' :
            'ONDA ↔ PARTÍCULA';
        
        time++;
        requestAnimationFrame(animate);
    }
    
    // Event listeners
    canvas.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
        
        const centerDistance = Math.sqrt(
            Math.pow(mouseX - canvas.width/2, 2) + 
            Math.pow(mouseY - canvas.height/2, 2)
        );
        observerIntensity = Math.max(0, 1 - centerDistance / 300);
    });
    
    canvas.addEventListener('click', () => {
        // Colapsar función de onda manualmente
        collapsed = true;
        collapsePoint = { x: mouseX, y: mouseY };
        
        // Reorganizar partículas
        thoughtParticles.forEach(particle => {
            particle.isWave = !particle.isWave;
        });
        
        setTimeout(() => {
            collapsed = false;
            collapsePoint = null;
        }, 1500);
    });
    
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });
    
    // Iniciar
    animate();
    
    console.log('%c🧠 Psicología Cuántica Activada ⚛️', 'color: #9370FF; font-size: 16px; font-weight: bold;');
    console.log('%cLa mente observa y colapsa su propia realidad', 'color: #00ffff; font-size: 12px;');
</script>
```

</body>
</html>
