<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trinity 3.0 - Portal Completo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: radial-gradient(ellipse at center, #0a0a0a 0%, #000000 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            cursor: crosshair;
        }

        canvas {
            display: block;
            filter: contrast(1.2) brightness(1.1);
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255,255,255,0.8);
            font-size: 11px;
            letter-spacing: 2px;
            z-index: 10;
            text-shadow: 0 0 10px currentColor;
        }

        .hud div {
            margin-bottom: 8px;
            opacity: 0;
            animation: fadeIn 2s forwards;
        }

        .hud span {
            color: #00ffff;
            font-weight: bold;
        }

        @keyframes fadeIn { to { opacity: 1; } }

        .portal-info {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.6);
            font-size: 12px;
            letter-spacing: 3px;
            animation: pulse 4s infinite;
            pointer-events: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.8; }
        }

        .sacred-symbols {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255,255,255,0.4);
            font-size: 18px;
            letter-spacing: 8px;
            animation: rotate 120s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .meditation-controls {
            position: absolute;
            bottom: 70px;
            left: 20px;
            display: flex;
            gap: 10px;
        }

        .meditation-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: rgba(255,255,255,0.8);
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .meditation-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }

        .meditation-btn.active {
            background: rgba(0,255,255,0.3);
            border-color: #00ffff;
        }
    </style>
</head>
<body>
    <div class="hud">
        <div style="animation-delay: 0.5s">DIMENSI√ìN: <span id="dimension">4D</span></div>
        <div style="animation-delay: 1s">RESONANCIA: <span id="resonance">0</span>%</div>
        <div style="animation-delay: 1.5s">FRECUENCIA: <span id="frequency">528</span> Hz</div>
        <div style="animation-delay: 2s">PATR√ìN: <span id="pattern">TRINITY</span></div>
        <div style="animation-delay: 2.5s">MEDITACI√ìN: <span id="meditation">INACTIVA</span></div>
        <div style="animation-delay: 3s">SONIDO: <span id="sound">OFF</span></div>
    </div>

    <div class="sacred-symbols">‚ö°üåÄ‚ú¶‚ôæÔ∏è‚≠ê</div>

    <div class="meditation-controls">
        <button class="meditation-btn" data-mode="activacion">ACTIVACI√ìN</button>
        <button class="meditation-btn" data-mode="sanacion">SANACI√ìN</button>
        <button class="meditation-btn" data-mode="expansion">EXPANSI√ìN</button>
        <button class="meditation-btn" id="soundToggle">SONIDO OFF</button>
    </div>

    <canvas id="canvas"></canvas>

    <div class="portal-info">
        ‚ú® CLICK: CAMBIAR PATR√ìN ‚Ä¢ DOBLE CLICK: MERKABA ‚Ä¢ MEDITACI√ìN AUTOM√ÅTICA ‚ú®
    </div>

    <!-- Audio para frecuencias solfeggio -->
    <audio id="solfeggioAudio" loop></audio>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const audio = document.getElementById('solfeggioAudio');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Variables globales
        let time = 0;
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;
        let pattern = 0;
        let merkabaMode = false;
        let breathPhase = 0;
        let soundEnabled = false;
        let meditationActive = false;
        let currentMeditation = '';
        let meditationStep = 0;
        let meditationTimer = 0;
        
        const patterns = [
            'TRINITY SAGRADA',
            'EXPANSI√ìN C√ìSMICA', 
            'ESPIRAL EVOLUTIVA',
            'FLOR DE LA VIDA',
            'TOROIDE CARD√çACO',
            'GEOMETR√çA FRACTAL',
            'MERKABA ACTIVADO',
            'CONVERGENCIA UNITARIA'
        ];

        // Secuencias de meditaci√≥n
        const meditationSequences = {
            'activacion': [0, 1, 4, 6, 7], // 30 segundos cada uno
            'sanacion': [0, 3, 5, 2],      // 40 segundos cada uno  
            'expansion': [1, 4, 6, 5]      // 35 segundos cada uno
        };

        // Frecuencias Solfeggio
        const solfeggioFrequencies = {
            396: 'Liberaci√≥n',
            417: 'Cambio',
            528: 'Amor/Reparaci√≥n', 
            639: 'Conexi√≥n',
            741: 'Despertar',
            852: 'Retorno espiritual'
        };

        // Sistema de esferas mejorado
        class Sphere {
            constructor(x, y, radius, color, phase) {
                this.x = x;
                this.y = y;
                this.z = 0;
                this.radius = radius;
                this.baseRadius = radius;
                this.color = color;
                this.phase = phase;
                this.pulsePhase = 0;
                this.orbitals = [];
                
                for (let i = 0; i < 3; i++) {
                    this.orbitals.push({
                        angle: Math.random() * Math.PI * 2,
                        radius: 20 + i * 15,
                        speed: 0.02 + i * 0.01,
                        size: 2 + i
                    });
                }
            }
            
            draw() {
                const pulse = 0.7 + Math.sin(this.pulsePhase) * 0.3;
                const currentRadius = this.radius * pulse;
                
                // Aura expansiva
                const auraGradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, currentRadius * 3
                );
                auraGradient.addColorStop(0, this.color + '30');
                auraGradient.addColorStop(0.7, this.color + '10');
                auraGradient.addColorStop(1, 'transparent');
                
                ctx.fillStyle = auraGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentRadius * 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Esfera principal
                for (let layer = 3; layer >= 0; layer--) {
                    const layerRadius = currentRadius * (1 - layer * 0.1);
                    const alpha = Math.floor(60 + layer * 15).toString(16);
                    
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, layerRadius, 0, Math.PI * 2);
                    ctx.strokeStyle = this.color + alpha;
                    ctx.lineWidth = 2 - layer * 0.3;
                    ctx.stroke();
                }
                
                // N√∫cleo brillante
                const coreGradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, currentRadius * 0.6
                );
                coreGradient.addColorStop(0, '#ffffff');
                coreGradient.addColorStop(0.4, this.color);
                coreGradient.addColorStop(1, 'transparent');
                
                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentRadius * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                // Orbitales
                this.orbitals.forEach(orbital => {
                    orbital.angle += orbital.speed;
                    
                    const orbX = this.x + Math.cos(orbital.angle) * orbital.radius;
                    const orbY = this.y + Math.sin(orbital.angle) * orbital.radius;
                    
                    ctx.beginPath();
                    ctx.arc(orbX, orbY, orbital.size, 0, Math.PI * 2);
                    ctx.fillStyle = this.color + 'cc';
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(orbX, orbY, orbital.size * 2, 0, Math.PI * 2);
                    ctx.strokeStyle = this.color + '40';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                });
                
                // Anillos de resonancia
                for (let ring = 1; ring <= 4; ring++) {
                    const ringRadius = currentRadius + ring * 20;
                    const ringAlpha = Math.floor(40 - ring * 8).toString(16);
                    const ringPulse = Math.sin(this.pulsePhase + ring) * 5;
                    
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, ringRadius + ringPulse, 0, Math.PI * 2);
                    ctx.strokeStyle = this.color + ringAlpha;
                    ctx.lineWidth = 0.8;
                    ctx.stroke();
                }
            }
            
            update(targetX, targetY, targetZ = 0) {
                this.x += (targetX - this.x) * 0.08;
                this.y += (targetY - this.y) * 0.08;
                this.z += (targetZ - this.z) * 0.08;
                
                this.pulsePhase += 0.03 + this.phase * 0.01;
                this.radius = this.baseRadius + Math.sin(breathPhase + this.phase) * 15;
            }
        }

        // Sistema de part√≠culas cu√°nticas
        class QuantumParticle {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.vx = (Math.random() - 0.5) * 0.3;
                this.vy = (Math.random() - 0.5) * 0.3;
                this.life = 1;
                this.size = Math.random() * 1.5 + 0.5;
                this.hue = Math.random() * 360;
            }
            
            update() {
                const dx = canvas.width/2 - this.x;
                const dy = canvas.height/2 - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist > 10) {
                    const force = 0.0001 * dist;
                    this.vx += (dx / dist) * force;
                    this.vy += (dy / dist) * force;
                }
                
                const mdx = mouseX - this.x;
                const mdy = mouseY - this.y;
                const mdist = Math.sqrt(mdx*mdx + mdy*mdy);
                
                if (mdist < 100) {
                    const mouseForce = 0.002 * (1 - mdist/100);
                    this.vx += (mdx / mdist) * mouseForce;
                    this.vy += (mdy / mdist) * mouseForce;
                }
                
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.002;
                
                if (this.life <= 0 || this.x < -50 || this.x > canvas.width + 50 || this.y < -50 || this.y > canvas.height + 50) {
                    this.reset();
                }
            }
            
            draw() {
                const alpha = this.life * 0.8;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${this.hue}, 70%, 60%, ${alpha})`;
                ctx.fill();
            }
        }

        // Crear esferas Trinity
        const spheres = [
            new Sphere(0, 0, 70, '#00ffff', 0),
            new Sphere(0, 0, 70, '#ff00ff', 2.094),  
            new Sphere(0, 0, 70, '#ffff00', 4.188)
        ];

        // Crear part√≠culas
        const particles = Array(333).fill().map(() => new QuantumParticle());

        // Sistema de audio
        function initAudio() {
            // Crear contexto de audio
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            const audioContext = new AudioContext();
            
            // Generar tono solfeggio
            function playSolfeggio(frequency) {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.value = frequency;
                
                gainNode.gain.value = 0.1;
                
                oscillator.start();
                
                // Fade out suave
                setTimeout(() => {
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 2);
                    setTimeout(() => oscillator.stop(), 2000);
                }, 8000);
            }
            
            return { playSolfeggio };
        }

        let audioSystem = null;

        // Geometr√≠a Metatr√≥n
        function drawMetatronCube() {
            ctx.save();
            ctx.translate(canvas.width/2, canvas.height/2);
            ctx.rotate(time * 0.0003);
            
            ctx.strokeStyle = 'rgba(255,255,255,0.04)';
            ctx.lineWidth = 0.4;
            
            // 13 esferas del Cubo de Metatr√≥n
            const metatronPoints = [];
            const radius = 120;
            
            // Esfera central
            metatronPoints.push({x: 0, y: 0});
            
            // Primer anillo - 6 esferas
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 / 6) * i;
                metatronPoints.push({
                    x: Math.cos(angle) * radius,
                    y: Math.sin(angle) * radius
                });
            }
            
            // Segundo anillo - 6 esferas
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 / 6) * i + Math.PI/6;
                metatronPoints.push({
                    x: Math.cos(angle) * radius * 1.732,
                    y: Math.sin(angle) * radius * 1.732
                });
            }
            
            // Conectar todas las esferas
            for (let i = 0; i < metatronPoints.length; i++) {
                for (let j = i + 1; j < metatronPoints.length; j++) {
                    ctx.beginPath();
                    ctx.moveTo(metatronPoints[i].x, metatronPoints[i].y);
                    ctx.lineTo(metatronPoints[j].x, metatronPoints[j].y);
                    ctx.stroke();
                }
                
                // Dibujar esferas
                ctx.beginPath();
                ctx.arc(metatronPoints[i].x, metatronPoints[i].y, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fill();
            }
            
            ctx.restore();
        }

        // Flor de la vida
        function drawFlowerOfLife() {
            ctx.save();
            ctx.translate(canvas.width/2, canvas.height/2);
            
            ctx.strokeStyle = 'rgba(255,255,255,0.03)';
            ctx.lineWidth = 0.5;
            
            // C√≠rculo central
            ctx.beginPath();
            ctx.arc(0, 0, 100, 0, Math.PI * 2);
            ctx.stroke();
            
            // Primer anillo
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 / 6) * i;
                const x = Math.cos(angle) * 100;
                const y = Math.sin(angle) * 100;
                
                ctx.beginPath();
                ctx.arc(x, y, 100, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.restore();
        }

        // Conexiones energ√©ticas
        function drawEnergyConnections() {
            for (let i = 0; i < spheres.length; i++) {
                for (let j = i + 1; j < spheres.length; j++) {
                    const s1 = spheres[i];
                    const s2 = spheres[j];
                    
                    const pulse = Math.sin(time * 0.02 + i + j) * 0.5 + 0.5;
                    
                    ctx.strokeStyle = s1.color + Math.floor(pulse * 80).toString(16);
                    ctx.lineWidth = 1 + pulse;
                    ctx.beginPath();
                    ctx.moveTo(s1.x, s1.y);
                    ctx.lineTo(s2.x, s2.y);
                    ctx.stroke();
                    
                    for (let p = 0; p < 2; p++) {
                        const t = ((time * 0.01 + p * 0.5) % 1);
                        const px = s1.x + (s2.x - s1.x) * t;
                        const py = s1.y + (s2.y - s1.y) * t;
                        
                        ctx.beginPath();
                        ctx.arc(px, py, 1.5, 0, Math.PI * 2);
                        ctx.fillStyle = '#ffffff' + Math.floor(pulse * 200).toString(16);
                        ctx.fill();
                    }
                }
            }
        }

        // Sistema de meditaci√≥n autom√°tica
        function updateMeditation() {
            if (!meditationActive) return;
            
            meditationTimer++;
            
            // Cambiar patr√≥n cada 5 segundos (300 frames a 60fps)
            if (meditationTimer > 300) {
                meditationStep = (meditationStep + 1) % meditationSequences[currentMeditation].length;
                pattern = meditationSequences[currentMeditation][meditationStep];
                meditationTimer = 0;
                
                // Tocar frecuencia solfeggio correspondiente
                if (soundEnabled && audioSystem) {
                    const frequencies = [528, 639, 741, 396, 417, 852];
                    audioSystem.playSolfeggio(frequencies[meditationStep % frequencies.length]);
                }
            }
        }

        // Animaci√≥n principal
        function animate() {
            ctx.fillStyle = 'rgba(0,0,0,0.08)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            breathPhase += 0.015;
            
            // Dibujar geometr√≠as de fondo
            drawFlowerOfLife();
            drawMetatronCube();
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Actualizar meditaci√≥n
            updateMeditation();
            
            // Actualizar posiciones seg√∫n patr√≥n
            switch(pattern) {
                case 0: spheres[0].update(centerX - 120, centerY - 70); spheres[1].update(centerX + 120, centerY - 70); spheres[2].update(centerX, centerY + 140); break;
                case 1: const expansion = 180 + Math.sin(breathPhase) * 80; spheres.forEach((sphere, i) => { const angle = (Math.PI * 2 / 3) * i + time * 0.005; sphere.update(centerX + Math.cos(angle) * expansion, centerY + Math.sin(angle) * expansion); }); break;
                case 2: spheres.forEach((sphere, i) => { const spiralTime = time * 0.01 + i * 2.094; const radius = 100 + Math.sin(spiralTime * 0.5) * 60; sphere.update(centerX + Math.cos(spiralTime) * radius, centerY + Math.sin(spiralTime) * radius); }); break;
                case 3: spheres[0].update(centerX, centerY); spheres[1].update(centerX + Math.cos(time * 0.008) * 150, centerY + Math.sin(time * 0.008) * 150); spheres[2].update(centerX + Math.cos(time * 0.008 + Math.PI) * 150, centerY + Math.sin(time * 0.008 + Math.PI) * 150); break;
                case 4: spheres.forEach((sphere, i) => { const toroidTime = time * 0.01 + i * 2.094; const x = Math.cos(toroidTime) * (100 + Math.cos(toroidTime * 3) * 40); const y = Math.sin(toroidTime) * (100 + Math.cos(toroidTime * 3) * 40); sphere.update(centerX + x, centerY + y); }); break;
                case 5: spheres.forEach((sphere, i) => { const fractalTime = time * 0.005 + i * 2.094; const radius = 120 + Math.sin(fractalTime * (i + 1)) * 40; sphere.update(centerX + Math.cos(fractalTime) * radius, centerY + Math.sin(fractalTime) * radius); }); break;
                case 6: if (merkabaMode) { spheres.forEach((sphere, i) => { const angle = (Math.PI * 2 / 3) * i + time * 0.02; const radius = 140; sphere.update(centerX + Math.cos(angle) * radius * Math.cos(time * 0.01), centerY + Math.sin(angle) * radius); }); } break;
                case 7: const convergence = (Math.sin(breathPhase) + 1) / 2; spheres.forEach((sphere, i) => { const angle = (Math.PI * 2 / 3) * i; const radius = 200 * (1 - convergence * 0.7); sphere.update(centerX + Math.cos(angle) * radius, centerY + Math.sin(angle) * radius); }); break;
            }
            
            // Dibujar elementos
            drawEnergyConnections();
            spheres.forEach(sphere => sphere.draw());
            particles.forEach(particle => { particle.update(); particle.draw(); });
            
            // Actualizar HUD
            const mouseDistance = Math.sqrt(Math.pow(mouseX - centerX, 2) + Math.pow(mouseY - centerY, 2));
            const resonance = Math.max(0, Math.min(100, 100 - mouseDistance / 4));
            
            document.getElementById('resonance').textContent = Math.floor(resonance);
            document.getElementById('pattern').textContent = patterns[pattern];
            document.getElementById('frequency').textContent = 432 + Math.floor(Math.sin(breathPhase) * 111);
            document.getElementById('dimension').textContent = merkabaMode ? '5D' : '4D';
            document.getElementById('meditation').textContent = meditationActive ? currentMeditation.toUpperCase() : 'INACTIVA';
            document.getElementById('sound').textContent = soundEnabled ? 'ON' : 'OFF';
            
            time++;
            requestAnimationFrame(animate);
        }

        // Controladores de meditaci√≥n
        document.querySelectorAll('.meditation-btn').forEach(btn => {
            if (btn.id === 'soundToggle') return;
            
            btn.addEventListener('click', () => {
                document.querySelectorAll('.meditation-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                if (meditationActive && currentMeditation === btn.dataset.mode) {
                    meditationActive = false;
                    currentMeditation = '';
                } else {
                    meditationActive = true;
                    currentMeditation = btn.dataset.mode;
                    meditationStep = 0;
                    meditationTimer = 0;
                    pattern = meditationSequences[currentMeditation][0];
                }
            });
        });

        // Controlador de sonido
        document.getElementById('soundToggle').addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            document.getElementById('soundToggle').textContent = soundEnabled ? 'SONIDO ON' : 'SONIDO OFF';
            
            if (soundEnabled && !audioSystem) {
                audioSystem = initAudio();
            }
        });

        // Event Listeners
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('click', () => {
            if (meditationActive) {
                meditationActive = false;
                document.querySelectorAll('.meditation-btn').forEach(b => b.classList.remove('active'));
            }
            pattern = (pattern + 1) % patterns.length;
            if (pattern === 6) merkabaMode = true;
        });

        canvas.addEventListener('dblclick', () => {
            merkabaMode = !merkabaMode;
            if (merkabaMode) pattern = 6;
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Iniciar
        animate();
        console.log('üåÄ Trinity 3.0 - Portal Completo Activado');
        console.log('‚ú® Caracter√≠sticas: Sonido Solfeggio + Metatr√≥n + Meditaci√≥n Guiada');
    </script>
</body>
</html>
