<!DOCTYPE html>

<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trinity - Campo de Resonancia Óptimo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    body {
        background: #000;
        overflow: hidden;
        cursor: crosshair;
        font-family: 'Courier New', monospace;
    }

    canvas {
        display: block;
        width: 100vw;
        height: 100vh;
    }

    .controls {
        position: absolute;
        top: 20px;
        left: 20px;
        color: rgba(255,255,255,0.7);
        font-size: 12px;
        letter-spacing: 2px;
        z-index: 10;
    }

    .controls div {
        margin-bottom: 8px;
        opacity: 0;
        animation: fadeIn 2s forwards;
    }

    .controls span {
        color: #00ffff;
        font-weight: bold;
    }

    @keyframes fadeIn {
        to { opacity: 0.9; }
    }

    .instructions {
        position: absolute;
        bottom: 20px;
        width: 100%;
        text-align: center;
        color: rgba(255,255,255,0.3);
        font-size: 11px;
        letter-spacing: 3px;
    }

    .sacred-number {
        position: absolute;
        top: 20px;
        right: 20px;
        color: rgba(255,255,255,0.2);
        font-size: 48px;
        font-weight: bold;
        opacity: 0.3;
    }
</style>
```

</head>
<body>
    <div class="controls">
        <div style="animation-delay: 0.5s">PATRÓN: <span id="pattern">TRINITY</span></div>
        <div style="animation-delay: 1s">RESONANCIA: <span id="resonance">0</span>%</div>
        <div style="animation-delay: 1.5s">FRECUENCIA: <span id="frequency">432</span> Hz</div>
        <div style="animation-delay: 2s">COHERENCIA: <span id="coherence">0</span>%</div>
        <div style="animation-delay: 2.5s">PORTAL: <span id="portal">1</span>/33</div>
    </div>

```
<div class="sacred-number">33</div>

<canvas id="canvas"></canvas>

<div class="instructions">
    CLICK: CAMBIAR PATRÓN • ESPACIO: ACTIVAR MERKABA • MOVER: MODULAR CAMPO
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Configuración responsiva
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Variables del sistema
    let time = 0;
    let mouseX = canvas.width / 2;
    let mouseY = canvas.height / 2;
    let currentPattern = 0;
    let breathPhase = 0;
    let merkabaActive = false;
    let portalPhase = 0;
    
    // Patrones disponibles
    const patterns = [
        'TRINITY',
        'EXPANSIÓN',
        'CONVERGENCIA', 
        'ESPIRAL',
        'MERKABA',
        'TOROIDE',
        'FLOR DE VIDA',
        'FRACTAL'
    ];
    
    // Clase Esfera Optimizada
    class TrinitySphere {
        constructor(index, color, frequency) {
            this.index = index;
            this.color = color;
            this.frequency = frequency;
            this.x = canvas.width / 2;
            this.y = canvas.height / 2;
            this.z = 0;
            this.radius = 60;
            this.phase = (Math.PI * 2 / 3) * index;
            this.pulsePhase = 0;
            this.glowIntensity = 0;
        }
        
        update(targetX, targetY, targetZ = 0) {
            // Suavizado de movimiento
            this.x += (targetX - this.x) * 0.08;
            this.y += (targetY - this.y) * 0.08;
            this.z += (targetZ - this.z) * 0.08;
            
            // Pulsación vital
            this.pulsePhase += 0.02;
            this.glowIntensity = (Math.sin(this.pulsePhase + this.phase) + 1) / 2;
        }
        
        draw() {
            const perspective = 1 + this.z / 1000;
            const adjustedRadius = this.radius * perspective;
            const adjustedX = this.x;
            const adjustedY = this.y;
            
            // Glow exterior
            const glowGradient = ctx.createRadialGradient(
                adjustedX, adjustedY, 0,
                adjustedX, adjustedY, adjustedRadius * 2
            );
            glowGradient.addColorStop(0, this.color + '40');
            glowGradient.addColorStop(0.5, this.color + '15');
            glowGradient.addColorStop(1, 'transparent');
            
            ctx.fillStyle = glowGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Esfera principal
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 2 * perspective;
            ctx.beginPath();
            ctx.arc(adjustedX, adjustedY, adjustedRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Núcleo brillante
            const coreGradient = ctx.createRadialGradient(
                adjustedX, adjustedY, 0,
                adjustedX, adjustedY, adjustedRadius * 0.3
            );
            coreGradient.addColorStop(0, '#ffffff');
            coreGradient.addColorStop(0.5, this.color);
            coreGradient.addColorStop(1, 'transparent');
            
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(adjustedX, adjustedY, adjustedRadius * 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // Anillos orbitales
            ctx.strokeStyle = this.color + '30';
            ctx.lineWidth = 0.5;
            for (let i = 1; i <= 3; i++) {
                ctx.beginPath();
                ctx.arc(adjustedX, adjustedY, adjustedRadius + i * 20, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
    }
    
    // Crear las tres esferas
    const spheres = [
        new TrinitySphere(0, '#00ffff', 528),  // Cyan - Transformación
        new TrinitySphere(1, '#ff00ff', 639),  // Magenta - Conexión
        new TrinitySphere(2, '#ffff00', 741)   // Amarillo - Despertar
    ];
    
    // Sistema de partículas optimizado
    class Particle {
        constructor() {
            this.reset();
        }
        
        reset() {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * Math.min(canvas.width, canvas.height) / 2;
            this.x = canvas.width / 2 + Math.cos(angle) * distance;
            this.y = canvas.height / 2 + Math.sin(angle) * distance;
            this.vx = (Math.random() - 0.5) * 0.5;
            this.vy = (Math.random() - 0.5) * 0.5;
            this.life = 1;
            this.size = Math.random() * 2 + 0.5;
        }
        
        update() {
            // Atracción al centro
            const dx = canvas.width / 2 - this.x;
            const dy = canvas.height / 2 - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > 10) {
                this.vx += (dx / dist) * 0.001;
                this.vy += (dy / dist) * 0.001;
            }
            
            // Influencia del mouse
            const mdx = mouseX - this.x;
            const mdy = mouseY - this.y;
            const mdist = Math.sqrt(mdx * mdx + mdy * mdy);
            
            if (mdist < 100) {
                this.vx += (mdx / mdist) * 0.002;
                this.vy += (mdy / mdist) * 0.002;
            }
            
            this.x += this.vx;
            this.y += this.vy;
            this.life -= 0.002;
            
            if (this.life <= 0) this.reset();
        }
        
        draw() {
            ctx.fillStyle = `rgba(255, 255, 255, ${this.life * 0.5})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    // Crear sistema de partículas (150 para optimización)
    const particles = Array(150).fill().map(() => new Particle());
    
    // Geometría sagrada de fondo
    function drawSacredGeometry() {
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate(time * 0.0005);
        
        // Flor de la vida simplificada
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)';
        ctx.lineWidth = 0.5;
        
        // Círculo central
        ctx.beginPath();
        ctx.arc(0, 0, 100, 0, Math.PI * 2);
        ctx.stroke();
        
        // 6 pétalos principales
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI * 2 / 6) * i;
            const x = Math.cos(angle) * 100;
            const y = Math.sin(angle) * 100;
            ctx.beginPath();
            ctx.arc(x, y, 100, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        ctx.restore();
    }
    
    // Portal del vacío
    function drawVoidPortal() {
        // Centro de gravedad de las esferas
        let centerX = 0, centerY = 0;
        spheres.forEach(sphere => {
            centerX += sphere.x;
            centerY += sphere.y;
        });
        centerX /= spheres.length;
        centerY /= spheres.length;
        
        // Portal pulsante
        portalPhase += 0.02;
        const portalSize = 8 + Math.sin(portalPhase) * 4;
        
        // Punto de singularidad
        ctx.beginPath();
        ctx.arc(centerX, centerY, portalSize, 0, Math.PI * 2);
        ctx.fillStyle = '#ffffff';
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#ffffff';
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Halo del portal
        const haloGradient = ctx.createRadialGradient(
            centerX, centerY, 0,
            centerX, centerY, 50
        );
        haloGradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
        haloGradient.addColorStop(1, 'transparent');
        
        ctx.fillStyle = haloGradient;
        ctx.beginPath();
        ctx.arc(centerX, centerY, 50, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Conexiones energéticas
    function drawConnections() {
        spheres.forEach((sphere1, i) => {
            spheres.forEach((sphere2, j) => {
                if (i < j) {
                    const gradient = ctx.createLinearGradient(
                        sphere1.x, sphere1.y,
                        sphere2.x, sphere2.y
                    );
                    gradient.addColorStop(0, sphere1.color + '20');
                    gradient.addColorStop(0.5, '#ffffff10');
                    gradient.addColorStop(1, sphere2.color + '20');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(sphere1.x, sphere1.y);
                    ctx.lineTo(sphere2.x, sphere2.y);
                    ctx.stroke();
                }
            });
        });
    }
    
    // Merkaba simplificado
    function drawMerkaba() {
        if (!merkabaActive) return;
        
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate(time * 0.01);
        
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        
        // Triángulo superior
        ctx.beginPath();
        ctx.moveTo(0, -100);
        ctx.lineTo(-87, 50);
        ctx.lineTo(87, 50);
        ctx.closePath();
        ctx.stroke();
        
        // Triángulo inferior (invertido)
        ctx.beginPath();
        ctx.moveTo(0, 100);
        ctx.lineTo(-87, -50);
        ctx.lineTo(87, -50);
        ctx.closePath();
        ctx.stroke();
        
        ctx.restore();
    }
    
    // Actualizar posiciones según patrón
    function updatePattern() {
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        
        switch(currentPattern) {
            case 0: // TRINITY - Formación triangular clásica
                spheres[0].update(cx - 100, cy - 60, 0);
                spheres[1].update(cx + 100, cy - 60, 0);
                spheres[2].update(cx, cy + 120, 0);
                break;
                
            case 1: // EXPANSIÓN
                const expandRadius = 120 + Math.sin(breathPhase) * 60;
                spheres.forEach((sphere, i) => {
                    const angle = (Math.PI * 2 / 3) * i + time * 0.005;
                    sphere.update(
                        cx + Math.cos(angle) * expandRadius,
                        cy + Math.sin(angle) * expandRadius,
                        Math.sin(time * 0.01) * 50
                    );
                });
                break;
                
            case 2: // CONVERGENCIA
                const convergeRadius = 50 + Math.abs(Math.sin(breathPhase)) * 100;
                spheres.forEach((sphere, i) => {
                    const angle = (Math.PI * 2 / 3) * i;
                    sphere.update(
                        cx + Math.cos(angle) * convergeRadius,
                        cy + Math.sin(angle) * convergeRadius,
                        -Math.abs(Math.sin(breathPhase)) * 100
                    );
                });
                break;
                
            case 3: // ESPIRAL
                spheres.forEach((sphere, i) => {
                    const spiralTime = time * 0.01 + i * 2.094;
                    const radius = 80 + Math.sin(spiralTime * 0.5) * 40;
                    sphere.update(
                        cx + Math.cos(spiralTime) * radius,
                        cy + Math.sin(spiralTime) * radius,
                        Math.sin(spiralTime * 2) * 50
                    );
                });
                break;
                
            case 4: // MERKABA
                merkabaActive = true;
                spheres.forEach((sphere, i) => {
                    const angle = (Math.PI * 2 / 3) * i + time * 0.01;
                    sphere.update(
                        cx + Math.cos(angle) * 100,
                        cy + Math.sin(angle) * 100,
                        Math.sin(angle * 2) * 50
                    );
                });
                break;
                
            case 5: // TOROIDE
                spheres.forEach((sphere, i) => {
                    const toroidAngle = time * 0.01 + i * 2.094;
                    const majorRadius = 80;
                    const minorRadius = 40;
                    const x = Math.cos(toroidAngle) * (majorRadius + Math.cos(toroidAngle * 3) * minorRadius);
                    const y = Math.sin(toroidAngle) * (majorRadius + Math.cos(toroidAngle * 3) * minorRadius);
                    sphere.update(cx + x, cy + y, Math.sin(toroidAngle * 3) * 30);
                });
                break;
                
            case 6: // FLOR DE VIDA
                const flowerAngle = time * 0.005;
                spheres[0].update(cx, cy, 0);
                spheres[1].update(
                    cx + Math.cos(flowerAngle) * 120,
                    cy + Math.sin(flowerAngle) * 120,
                    0
                );
                spheres[2].update(
                    cx + Math.cos(flowerAngle + Math.PI) * 120,
                    cy + Math.sin(flowerAngle + Math.PI) * 120,
                    0
                );
                break;
                
            case 7: // FRACTAL
                spheres.forEach((sphere, i) => {
                    const fractalAngle = (Math.PI * 2 / 3) * i + time * 0.003;
                    const fractalRadius = 100 + Math.sin(time * 0.01 * (i + 1)) * 30;
                    sphere.update(
                        cx + Math.cos(fractalAngle) * fractalRadius,
                        cy + Math.sin(fractalAngle) * fractalRadius,
                        Math.sin(time * 0.02 + i) * 30
                    );
                });
                break;
        }
    }
    
    // Loop de animación principal
    function animate() {
        // Limpiar con estela
        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Actualizar tiempo y respiración
        time++;
        breathPhase += 0.01;
        
        // Dibujar elementos en orden
        drawSacredGeometry();
        updatePattern();
        drawConnections();
        
        // Dibujar esferas
        spheres.forEach(sphere => sphere.draw());
        
        // Dibujar portal central
        drawVoidPortal();
        
        // Dibujar Merkaba si está activo
        drawMerkaba();
        
        // Actualizar y dibujar partículas
        particles.forEach(particle => {
            particle.update();
            particle.draw();
        });
        
        // Actualizar HUD
        const mouseDistance = Math.sqrt(
            Math.pow(mouseX - canvas.width / 2, 2) + 
            Math.pow(mouseY - canvas.height / 2, 2)
        );
        
        const resonance = Math.max(0, Math.min(100, 100 - mouseDistance / 5));
        const coherence = Math.abs(Math.sin(breathPhase)) * 100;
        const frequency = Math.floor(432 + Math.sin(breathPhase) * 111);
        const portal = Math.floor((Math.sin(portalPhase) + 1) * 16.5) + 1;
        
        document.getElementById('pattern').textContent = patterns[currentPattern];
        document.getElementById('resonance').textContent = Math.floor(resonance);
        document.getElementById('frequency').textContent = frequency;
        document.getElementById('coherence').textContent = Math.floor(coherence);
        document.getElementById('portal').textContent = portal;
        
        requestAnimationFrame(animate);
    }
    
    // Event listeners
    canvas.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
    });
    
    canvas.addEventListener('click', () => {
        currentPattern = (currentPattern + 1) % patterns.length;
        if (currentPattern !== 4) {
            merkabaActive = false;
        }
    });
    
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
            e.preventDefault();
            merkabaActive = !merkabaActive;
        }
    });
    
    // Iniciar animación
    animate();
    
    // Mensaje en consola
    console.log('%c✨ Trinity Campo Óptimo Activado ✨', 'color: #00ffff; font-size: 16px; font-weight: bold;');
    console.log('%c33 Portales Dimensionales Sincronizados', 'color: #ff00ff; font-size: 12px;');
</script>
```

</body>
</html>
